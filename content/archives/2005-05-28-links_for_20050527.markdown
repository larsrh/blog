---
layout: post
title: "links for 2005-05-27"
date: "2005-05-28T01:22:00+01:00"
comments: false
categories: 
---

<ul class="delicious">
<li>
</li>
<li>
</li>
</ul>

<section class="comments">

<div class="comment" id="comment-551">
On <a href="#comment-551" title="Permalink to this comment">May 28, 2005  5:29 AM</a>, <a href="http://creativekarma.com/" title="http://creativekarma.com/" rel="nofollow">Doug</a>
said:
<p>Actually, the top-down vs. bottom-up thing isn&#8217;t &#8220;obvious&#8221; to me.</p>

<p>A purely top-down approach to analysis is suitable for a single simple application, but it doesn&#8217;t work well at producing a solid domain layer that can be used with multiple applications. The domain layer needs to be analyzed first (but not necessarily designed and built). After the domain layer is understood, then one can approach the process of analyzing applications in a top-down or use-case-driven manner.</p>

<p>One can certainly argue that the analysis of the domain layer needs to be informed by a general idea of what application(s) are going to be built on it, but I don&#8217;t think that makes it a truly top-down operation.</p>

<p>Following the analysis, the design and construction of both domain layer and application tends to take place in vertical slices - use cases, user stories, features, or whatever your favorite process calls it. I&#8217;m not convinced that top-down or bottom-up construction makes a whole lot of difference. Personally, I lean toward bottom-up construction so that I can perform testing on the evolving slice without resorting to mocks and stubs.</p>


<div class="comment" id="comment-552">
On <a href="#comment-552" title="Permalink to this comment">May 28, 2005 11:36 AM</a>, <a href="/en/staff/st/">Stefan Tilkov</a>
said:
<p>Doug, I see your point. Still, I believe that even if multiple applications are to share a common foundation, it&#8217;s a mistake to build that foundation from the bottom up. I think it&#8217;s more useful to extract the foundation after the first application has been built. Granted, you&#8217;ll pay a price because you will have to change some things that are based on assumptions that only hold true for the first app; your chances for success are large nonetheless.</p>

<p>I&#8217;ve seen quite a few projects where the bottom-up approach has led to a rather perfect and complex set of base libraries that nobody ends up using in the end, while the main goal - a running application - is never achieved.</p>


<div class="comment" id="comment-553">
On <a href="#comment-553" title="Permalink to this comment">May 29, 2005  6:08 PM</a>, <a href="http://creativekarma.com/" title="http://creativekarma.com/" rel="nofollow">Doug</a>
said:
<p>But refactoring a production application is often impossible. Most of the companies I&#8217;ve worked for in the past 20 years have forbidden changing production applications without an approved Change Request (or whatever the local terminology is). Refactoring is all well-and-good while doing green-field development, but you can&#8217;t count on using it once an application gets approved to production.</p>

<p>The trick is to do the domain <em>analysis</em> based on the application at hand and the projected future applications. But building the actual domain libraries - and their underlying database tables - happens incrementally, as needed by the slices (use cases, user stories, features, whatever) being developed.</p>

<p>The &#8220;fully agile&#8221; alternative typically ends up with separate (and often incompatible) domain implementations for each application. Attempting to control the incompatibility results in one of Michael Koziarski&#8217;s points about the difficulty of enterprise sofware development, where a new application is required to conform to existing database tables that were poorly considered and are not well-suited to the new application. And with each new application that twists itself to use the misfitting tables, those tables become ever more resistant to being changed. <a href="http://www.koziarski.net/archives/2005/05/21/enterprise-development" rel="nofollow" /><a href="http://www.koziarski.net/archives/2005/05/21/enterprise-development" rel="nofollow">http://www.koziarski.net/archives/2005/05/21/enterprise-development</a></p>


<div class="comment" id="comment-554">
On <a href="#comment-554" title="Permalink to this comment">May 30, 2005 10:43 AM</a>, <a href="/en/staff/st/">Stefan Tilkov</a>
said:
<p>Granted, in a situation where change is virtually impossible after you&#8217;ve shipped a first release, you&#8217;ll have to act differently. Most large-scale apps I have seen developed went through several &#8220;major&#8221; releases, where each release offered the opportunity to introduce rather drastic changes &#8212; which is OK, in my opinion, provided you know what you are doing (which is admittedly not always the case).</p>

<p>What I have seen way too often, though, is the other extreme - things are kept so general-purpose and generic that they take into account a multitude of possibilities that are never really needed &#8212; the system is built with a flexibility and an attempt at future-proof structure that never pays off.</p>


</section>

