<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rest on Stefan Tilkov’s Blog</title>
    <link>https://www.innoq.com/blog/st/categories/rest/index.xml</link>
    <description>Recent content in Rest on Stefan Tilkov’s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://www.innoq.com/blog/st/categories/rest/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Web-based frontend integration</title>
      <link>https://www.innoq.com/blog/st/2014/11/web-based-frontend-integration/</link>
      <pubDate>Sat, 29 Nov 2014 17:40:35 +0100</pubDate>
      
      <guid>https://www.innoq.com/blog/st/2014/11/web-based-frontend-integration/</guid>
      <description>&lt;p&gt;So &lt;a href=&#34;https://www.innoq.com/blog/st/2013/10/on-monoliths/&#34;&gt;you started with a monolith&lt;/a&gt;, and decided to split things into
smaller units. Obviously, the next thing you need to consider is how
to integrate them to form a consistent whole. To do this, let’s start
with the non-obvious part: The frontend (the UI).&lt;/p&gt;

&lt;p&gt;If you look at what’s typically proposed, it seems entirely obvious
that there are two options: (1) We integrate on the client side, which
when dealing with web applications typically means using some sort of
integrating, JavaScript-based MVC framework or (2) We integrate on the
server side, using some sort of “orchestration”. (As you might have
guessed, I will be presenting a third option, the one that I actually
prefer, but let me set the stage first.)&lt;/p&gt;

&lt;p&gt;Let’s start with (1), the client-side integration option, since things
like Angular.js are all the rage these days. Our goal is to create an
integrated UI, so as a first step, we can assume that if our server
just provides us with lots of small services, each of them offering an
HTTP/JSON API (RESTful or not, doesn’t really matter in this
context). Our client-side JavaScript logic will talk to multiple
services and create a composite UI based on the results. It’s the
client code’s responsibility to call the services in the right
sequence and combine their results (if all goes well) or deal with
failure (if it doesn’t). There are excellent libraries and frameworks
for doing this, and you can pick the one that best suits your taste
from the likes of Angular, Ember, and many others.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.innoq.com/blog/st/blog/st/images/client.png&#34; alt=&#34;Integration via a
client-side framework&#34; /&gt;&lt;/p&gt;

&lt;p&gt;One problem you’ll very often run into with option (1) is that the
services on the server side end up being quite fine-grained (a
consequence of their being reusable in many contexts), which leads to
a huge number of remote calls that are required between the client and
the server. Another downside typically results from the fact that you
can never rely on anything computed by the client, so you’ll have to
validate it on the server side. This, in turn, can lead to duplication
of at least parts of your logic.&lt;/p&gt;

&lt;p&gt;The solution to both of these problems typically is to perform
integration, or orchestration if you prefer, on the server side –
option (2). In other words, a server-side service will invoke other,
lower-level services, taking care of combination and error handling,
interpreting the client request and returning the aggregated result in
the end. This is of course completely orthogonal to the architecture you
choose for your client, i.e. you could just as well return HTML from
your server and have a traditional, non-JS based client.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.innoq.com/blog/st/blog/st/images/server.png&#34; alt=&#34;Integration via a server-side
orchestration service&#34; /&gt;&lt;/p&gt;

&lt;p&gt;What’s not to like? What I do not like about this approach is that you
create yet another server-side service, which makes me question why
you created the lower-level ones in the first place. This also becomes
a bottleneck, as any change to one of the lower-level services will
require a change to the orchestrating service.&lt;/p&gt;

&lt;p&gt;But there’s a third option (finally!), one that doesn’t seem to even be
considered in many cases, although it is (in my not so humble opinion)
the most powerful one. This option (3) relies on an absolutely
magical concept called “link” (dumb joke, I know). To explore this, we
question one of the initial assumptions that led to having to
integrate on the client side or server side in the first place, namely
that for a web UI to be integrated, it needs to aggregate UIs from
different backend services into a single HTML page.&lt;/p&gt;

&lt;p&gt;Instead, we have each service return HTML that can be rendered by the
browser – in other words, we assume that each page can be assigned to
one of the services. Of course there are lots of relations to other
things, but we simply use links to point to them. One nice side effect
of this is that it becomes much easier to ensure we have a meaningful
URI for each of the pages returned (or resources exposed, pick
whatever terminology you prefer).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.innoq.com/blog/st/blog/st/images/link.png&#34; alt=&#34;Integration via links&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So option (3) leaves us with a number of self-contained web
applications that are integrated only by means of being linked to each
other. Apart from not connecting them to each other at all, I am not
aware of any sort of weaker coupling.&lt;/p&gt;

&lt;p&gt;Of course you should be highly skeptical by now: How is that supposed
to be “integration”? Surely this guy isn’t serious? Is he seriously
suggesting we revert back to a model that was hip a decade or two ago?
You bet I am, and I’ll explore some of your doubts in a future post.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hypermedia Benefits for M2M Communication</title>
      <link>https://www.innoq.com/blog/st/2012/06/hypermedia-benefits-for-m2m-communication/</link>
      <pubDate>Fri, 22 Jun 2012 15:00:00 +0100</pubDate>
      
      <guid>https://www.innoq.com/blog/st/2012/06/hypermedia-benefits-for-m2m-communication/</guid>
      <description>&lt;p&gt;Hypermedia is the topic that generates the most intensive
discussions in any REST training, workshop, or project. While the
other aspects of RESTful HTTP usage are pretty straightforward to
grasp and hard to argue with, the use of hypermedia in
machine-to-machine communication is a bit tougher to explain.&lt;/p&gt;

&lt;p&gt;If you are already convinced that REST is the right architectural
style for you, you can probably stop reading and switch over to Mike
Amundsen&amp;rsquo;s excellent &lt;a href=&#39;http://www.amundsen.com/hypermedia/hfactor/&#39;&gt;&amp;ldquo;H Factor&amp;rdquo; discussions&lt;/a&gt;.  That may be a bit tough to start with, though, so I
thought it might make sense to explain some of the ways I use to
&amp;ldquo;pitch&amp;rdquo; hypermedia. I&amp;rsquo;ve arrived at a number of explanations
and examples of meaningful hypermedia usage, explicitly targeted at
people who are not deep into REST yet:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&amp;ldquo;Service Document&amp;rdquo; and &amp;ldquo;Registries&amp;rdquo;&lt;/em&gt;: Especially for people with an
SOA/SOAP/WSDL/WS-* background, the idea of putting at least one
level of indirection between a client (consumer) and server
(provider) is well established. A link in a server response is a way
for a client to not couple itself to a particular server address,
and a server response including multiple links to &amp;ldquo;entry point&amp;rdquo;
resources is somewhat similar to a small registry. If providing
links to actual entry point resources is the only purpose of a
resource, I&amp;rsquo;ve become used to calling it a &amp;ldquo;service document&amp;rdquo;. Of
course these documents themselves can be linked to each other,
allowing for hierarchies or other relationships; they can support
queries that return a subset of services; they can be provided by
different servers themselves; and they are way more dynamic than a
typical registry setup. In other words, the very simple approach
included in HTTP is far more powerful than what most crazily
expensive registries provide.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Extensible contracts&lt;/em&gt;: The merits of being able to link to resources
can be exploited to add functionality to existing systems without
breaking their contracts. This is most visible in server responses
that have one or more places where you can put additional links. As
your server or service evolves, you can add links that will be
ignored by existing clients, but can be used by those that rely on
them. The concept of &amp;ldquo;a link to a resource&amp;rdquo; is both sufficiently
generic and specific to be meaningful enough, especially if you
include a way to specify what they actually mean via a link
rel=&amp;hellip; approach (but more on that in a separate post).&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Co-Location Independence&lt;/em&gt;: What I mean by this slightly weird term is
the fact that while resources that are exposed as part of a service
interface are sometimes (or maybe even often) designed in a way that
requires them to be part of the same implementation, they very often
are not, i. e. they could at least in theory be part of a different
system. (In fact you can reasonably argue that there should be no
assumption about this at all, neither on the server nor the client
side for something to be rightfully called &amp;ldquo;RESTful&amp;rdquo;, but I simply
haven&amp;rsquo;t found that to be doable in practice.) In those cases where
resource don&amp;rsquo;t need to be hosted by the same implementation, you can
and should couple them via links and have clients navigate them
instead of relying on common URI paths.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are quite a few more examples to talk about, but I won&amp;rsquo;t do that
now &lt;a href=&#39;https://twitter.com/stilkov/status/215916063790075907&#39;&gt;as I promised to publish something today &lt;/a&gt; and don&amp;rsquo;t want to get into
the habit of keeping drafts lying around for too long again. (I know,
lenghty this is probably not. Sue me.) So please
let me know in the comments what you think of these three if you&amp;rsquo;re just
starting to pick up REST, and what additional ways of explanations you
use if you already have done so.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>REST vs. Websockets, oh my</title>
      <link>https://www.innoq.com/blog/st/2012/02/rest-vs.-websockets-oh-my/</link>
      <pubDate>Tue, 28 Feb 2012 19:31:00 +0100</pubDate>
      
      <guid>https://www.innoq.com/blog/st/2012/02/rest-vs.-websockets-oh-my/</guid>
      <description>&lt;p&gt;There is an entirely absurd discussion going on about &amp;ldquo;REST
vs. Websockets&amp;rdquo;, predictably claiming that in the long term, REST will
be succeeded by Websockets. This is stupid on many levels. I&amp;rsquo;ll try
to be brief:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To be pedantic, REST vs. &amp;hellip; almost never makes sense, as people are
rarely talking about REST (the architectural style) in comparison to
another architectural style. But never mind, let&amp;rsquo;s assume that what
was meant was actually &amp;ldquo;RESTful HTTP&amp;rdquo; vs. &amp;ldquo;Websockets&amp;rdquo;, then &amp;hellip;&lt;/li&gt;
&lt;li&gt;Websockets is not something &amp;ldquo;more&amp;rdquo;, it doesn&amp;rsquo;t add something, it&amp;rsquo;s
not dynamic, or interactive, or in any way &amp;ldquo;good&amp;rdquo; &amp;ndash; unless you make
the same claim about TCP. Websockets essentially allows you build
your own proprietary protocols that may or may not be great, with
all the typical advantages and disadvantages these end up having:
possibly better performance, possibly better suited to the specific
task at hand, less standardized, not widely implemented, etc. It&amp;rsquo;s
not a case of one being better than the other, it&amp;rsquo;s about being
different.&lt;/li&gt;
&lt;li&gt;In the long run, HTTP (used in a way aligned with its architectural
goals) will continue to have benefits for loosely coupling
systems. If that&amp;rsquo;s what you want, it makes the most sense. If you&amp;rsquo;re
after the most efficient communication possible, and are willing to
sacrifice some of the loose coupling &amp;ndash; fine, go ahead, use
Websockets. But it&amp;rsquo;s not as if one will supersede the other.&lt;/li&gt;
&lt;li&gt;Does this mean I claim that HTTP is perfect? Of course not, it most
definitely could be improved. But if this improvement comes, it&amp;rsquo;s
definitely going to introduce more, not less constraints.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Media Types in RESTful HTTP</title>
      <link>https://www.innoq.com/blog/st/2011/12/media-types-in-restful-http/</link>
      <pubDate>Sat, 03 Dec 2011 11:15:00 +0100</pubDate>
      
      <guid>https://www.innoq.com/blog/st/2011/12/media-types-in-restful-http/</guid>
      <description>&lt;p&gt;A topic that comes up again and again in discussions about RESTful
design is what kinds of media type to use. I&amp;rsquo;ve changed my mind about
this a few times, often enough so that I believe it makes sense to write
a bit about my current thinking on this. (A &amp;ldquo;media type&amp;rdquo;, should you
happen to wonder what I&amp;rsquo;m talking about, is a specific format with a
well-defined name, in this context represented in the form of a media
type identifier such as &lt;code&gt;application/xml&lt;/code&gt; or &lt;code&gt;text/html&lt;/code&gt; or
&lt;code&gt;application/json&lt;/code&gt;. [That&amp;rsquo;s not 100% correct, but that doesn&amp;rsquo;t really
matter here.] A &amp;ldquo;hypermedia format&amp;rdquo; is one that includes links or other
hypermedia controls.)&lt;/p&gt;

&lt;p&gt;There are a number of different ways to deal with media types when
designing a RESTful HTTP system. One school of thought advises to
stick with hypermedia formats/media types that are well-defined and
widely understood, such as HTML or Atom. In other words: Whatever it
is you&amp;rsquo;re trying to send around as part of an HTTP message, use an
existing format, such as HTML, the main reason being that there are
many processors that are able to understand it. Use the appropriate
MIME identifier (such as &lt;code&gt;text/html&lt;/code&gt;) in Content-type headers. One can
make a strong case for this option: Hypermedia formats are
hard to design, so you should avoid inventing your own.&lt;/p&gt;

&lt;p&gt;But let&amp;rsquo;s assume you&amp;rsquo;ve decided to define your own hypermedia format,
&lt;a href=&#39;http://www.amundsen.com/blog/archives/1101&#39;&gt;mike
amundsen-style&lt;/a&gt;, whether by designing a completely new XML
vocabulary, your own JSON structure, or some other approach: What MIME
type do you use?&lt;/p&gt;

&lt;p&gt;You can send content labeling it with the generic identifier, say
&lt;code&gt;application/xml&lt;/code&gt;. In this case, the MIME identifier will signal the
technical format being used, while the semantics are only known to
clients who either have some out-of-band knowledge or interpret the
content itself. The rationale for this approach is that unless your
home-grown hypermedia format is likely to be widely adopted, you&amp;rsquo;d
better stick with a media type that is well-known, even though it
doesn&amp;rsquo;t convey specific semantics. &lt;a href=&#39;http://duncan-cragg.org/blog/post/minting-media-types-usually-less-restful-using-raw/&#39;&gt;Duncan Cragg wrote a nice post&lt;/a&gt; on this a while back.&lt;/p&gt;

&lt;p&gt;The second option is to invent your own MIME type, say
&lt;code&gt;application/vnd.mycompany-myformat&lt;/code&gt;, the argument being that you need
to convey the semantics of the content to ensure a client, server or
intermediary can actually know whether it&amp;rsquo;s able to process it.&lt;/p&gt;

&lt;p&gt;This begs the question of how many different MIME types you&amp;rsquo;ll end up
with. Instead of creating a new identifier for each type of content,
(e.g. a customer, a list of customers, a list of orders), I&amp;rsquo;ve found
that a good approach is to think of a specific context &amp;ndash; a &lt;em&gt;domain&lt;/em&gt;, if
you prefer &amp;ndash; that your format covers. I like the similarity of this
approach to other hypermedia formats, e.g. HTML or Atom/AtomPub, where
you actually end up describing something that applies to a set of
collaborating participants, instead of some server-side interface. In
my favorite example domain (order processing), you might end up with a
MIME type of &lt;code&gt;application/vnd.mycompany-ordermanagement&lt;/code&gt;, relate this
to a particular XML namespace and define a few different XML root
elements (order, order confirmation, cancellation, etc.). The
assumption would be that processors can be reasonably expected to able
to understand all of the elements in this context, not just one of
them. (Of course the same reasoning applies when using JSON or
something else, minus the namespace benefits/troubles, depending on
your view of XML.)&lt;/p&gt;

&lt;p&gt;One final approach that I find very interesting was mentioned by &lt;a
href=&#39;http://algermissen.blogspot.com/&#39;&gt;Jan Algermissen&lt;/a&gt; a while
ago: If your format is based on an existing one, e.g. HTML or XML,
your server can actually send the same content with different MIME
types, depending on the client&amp;rsquo;s capabilities. A client that only
included &lt;code&gt;application/json&lt;/code&gt; in its Accept header would then get the
content labeled &lt;code&gt;application/json&lt;/code&gt;, while one that includes the
specific MIME type &lt;code&gt;application/vnd.whatever&lt;/code&gt; would get the same
content with this label applied.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>