<!DOCTYPE html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="Stefan Tilkov">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="canonical" href="https://www.innoq.comhttps://www.innoq.com/blog/st/2008/04/jruby-and-ruby/">
  <link href="/blog/st/favicon.png" rel="icon">
  <link href="/blog/st/atom.xml" rel="alternate" title="Stefan Tilkov's Blog" type="application/atom+xml">


  <link rel="stylesheet" href="https://bootstrap.assets.innoq.com/css/0.0.9/innoq-bootstrap-theme.css" />
  <link rel="stylesheet" href="/blog/st/stylesheets/blog.css" />

  <title>JRuby and Ruby [Stefan Tilkov’s Blog]</title>
  
</head>


  <body>

    <nav class="navbar navbar-expand-lg navbar-light">
  <a class="navbar-brand m-2 p-2" href="https://www.innoq.com/"><img alt="INNOQ logo" height="40" src="https://innoq.style/assets/innoq-logo--whitered.svg" /></a>
  <a class="navbar-brand text-light" href="/blog/st/">Stefan Tilkov’s Blog Archive</a>
</nav>





    <main class="container">
      <p class="mt-5"><em>
	This is a single archived entry from Stefan Tilkov’s blog. For more up-to-date content,
	check out my <a href="https://www.innoq.com/en/staff/stefan-tilkov/">author page at INNOQ</a>,
	which has more information about me and also contains a list of published talks, podcasts, and articles.
	Or you can check out the <a href="/blog/st/">full archive</a>.

      </em></p>
      <article>
	<header>
          <h1>JRuby and Ruby</h1>
	  <p><small><a href="https://www.innoq.com/en/staff/stefan-tilkov/">Stefan Tilkov</a>, <time datetime="2017-06-26">Apr 30, 2008</time></small><p>
	</header>
	<section>
	  <p>I spent a lot of time at JAX last week in discussions about Ruby and Rails, both on stage and offline. A recurring theme was the Java community's reluctance to accept anything that doesn't run on the JVM. The arguments brought forward can be separated roughly into the following three categories:</p>

<ul>
<li>Legacy. People insist on being able to protect their existing investments, in terms of hardware, software, and skills. Being able to run Ruby as just another language on the JVM, essentially including the option to simply deliver byte code without ever talking about a change in the programming language, is perceived as a key requirement.</li>
<li>Performance and Scalability. Scaling with processes instead of threads; having to manage a cluster of long-running processes; being forced to rely on Apache's features for load-balancing: there was general agreement that this is a lot worse than being able to rely on the existing Java infrastructure.</li>
</ul>

<p>I don't necessarily agree with these criticisms. For one, I believe systems should be coupled much more loosely than by running them on the same VM and integrating them on the language level. I also think that in many cases, scaling with processes in a shared-nothing architecture scales perfectly well, and it also doesn't require any sophisticated infrastructure beyond a boilerplate Unix platform. I expect a lot of innovation to occur within the Ruby VM space, specifically around Rubinius. And lastly, I know from personal experience that in many cases the JVM and a fat app server sitting on top of it are used to serve a simple JSP/servlet application to a few dozen users, i.e. used in a scenario where Perl CGI would suffice.</p>

<p>But while I don't find these arguments convincing enough for many use cases, it's very hard to find arguments <em>against</em> running Ruby on the JVM. JRuby has reached a level of maturity that makes it a great choice even if you don't care about Java at all. As it runs Rails, I'm reasonably confident it will run basically any Ruby library I could care about -- except, of course, those that rely on a native library to deliver their features. But in this case, the vast ecosystem of Java libraries should outweigh this disadvantage easily.</p>

<p>So assuming you can deploy your Ruby application to a JVM platform without hassle, why wouldn't you?</p>

<section class="comments">



<div class="comment" id="comment-1700">
On <a href="#comment-1700" title="Permalink to this comment">April 30, 2008  8:45 PM</a>, <a href="http://patricklogan.blogspot.com" title="http://patricklogan.blogspot.com" rel="nofollow">Patrick Logan</a>
said:
<p>I am far from experienced with this, but the one thing from a few releases ago for jruby was startup time for the jvm - all the class loading, etc. I think this has been an area of improvement for the jruby team.</p>

<p>Another reason could be better access to C libraries on the CRuby runtime. People have been working hard at making that a non-factor for JRuby as well, I know. But that often is resolved by reimplementing a C library in Java, which is not necessarily a desirable trend.</p>

<p>Mike &#8220;Fuzzy&#8221; Herrick has been using jruby/rails pretty heavily for many months now &#8212; he may have a good story to relate.</p>


<div class="comment" id="comment-1702">
On <a href="#comment-1702" title="Permalink to this comment">May  2, 2008  8:29 AM</a>, <a href="http://www.martin-probst.com" title="http://www.martin-probst.com" rel="nofollow">Martin Probst</a>
said:
<blockquote>
<p>&#8220;scaling with processes in a shared-nothing architecture scales perfectly well&#8221;</p>
</blockquote>

<p>I don&#8217;t agree with you on this. In current Rails land, you&#8217;ll need a process instance for each expected, concurrent user. Even trivial Rails applications consume something along the lines of 50 MB per process, and nearly all of that is non-shareable private heap space (i.e. no .so&#8217;s).</p>

<p>So if you expect 100 concurrent users on your webpage, you&#8217;re looking at 5000 MB RAM. Of course, 100 truly concurrent users is not really a piece of cake, but compare this to Java, PHP (ugh), &#8230; you name it, where at least the memory footprint won&#8217;t be a problem at all.</p>

<p>And less memory consumption of course means more buffers and caches, which can easily reduce your CPU problems.</p>

<p>If you run Comet-style applications or web apps where you need to access services in the background, with an accordingly large increase in response time but no CPU usage, 100 concurrent users is quite normal.</p>

<p>Scaling with processes does have problems.</p>


</section>

	</section>
      </article>
    </main>

  </body>
</html>


