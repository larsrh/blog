<!DOCTYPE html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="Stefan Tilkov">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="canonical" href="https://www.innoq.comhttps://www.innoq.com/blog/st/2005/05/rpc-style-web-services/">
  <link href="/blog/st/favicon.png" rel="icon">
  <link href="/blog/st/atom.xml" rel="alternate" title="Stefan Tilkov's Blog" type="application/atom+xml">


  <link rel="stylesheet" href="https://bootstrap.assets.innoq.com/css/0.0.9/innoq-bootstrap-theme.css" />
  <link rel="stylesheet" href="/blog/st/stylesheets/blog.css" />

  <title>RPC-style Web Services [Stefan Tilkov’s Blog]</title>
  
</head>


  <body>

    <nav class="navbar navbar-expand-lg navbar-light">
  <a class="navbar-brand m-2 p-2" href="https://www.innoq.com/"><img alt="INNOQ logo" height="40" src="https://innoq.style/assets/innoq-logo--whitered.svg" /></a>
  <a class="navbar-brand text-light" href="/blog/st/">Stefan Tilkov’s Blog Archive</a>
</nav>





    <main class="container">
      <p class="mt-5"><em>
	This is a single archived entry from Stefan Tilkov’s blog. For more up-to-date content,
	check out my <a href="https://www.innoq.com/en/staff/stefan-tilkov/">author page at INNOQ</a>,
	which has more information about me and also contains a list of published talks, podcasts, and articles.
	Or you can check out the <a href="/blog/st/">full archive</a>.

      </em></p>
      <article>
	<header>
          <h1>RPC-style Web Services</h1>
	  <p><small><a href="https://www.innoq.com/en/staff/stefan-tilkov/">Stefan Tilkov</a>, <time datetime="2017-06-26">May 18, 2005</time></small><p>
	</header>
	<section>
	  <p>Having finally found some time, this post continues <a href="/blog/st/2005/04/16/a_fresh_look_at_an_old_debate.html">my
little mini-series</a> on SOA styles. Once again a warning to the
experts: expect and please accept some oversimplification and a whole
lot of things that seem annoyingly obvious to you &#8212; but please do
point out any mistakes you might find.</p>

<p>The most pervasive Web services usage pattern is to use them as an
interoperable means of doing RPC (Remote Procedure Call)
programming. I have a very strong personal opinion about the
usefulness of this (read: I think it&#8217;s the wrong way to go); but
before I point out why I think so, let&#8217;s take a look at what it
actually is.</p>

<h3>A Brief introduction to RPC</h3>

<p>The goal of RPC in general is make distributed programming as easy as
possible by creating the illusion that an exchange of data over the
network that results in some processing (on another machine than the
one the application is running on) is nothing more than a special kind
of procedure call &#8212; one that has the special attribute of being
&#8220;remote&#8221;. Stating the obvious, there is a clear separation of roles in
this scenario: the application invoking the procedure (the caller) is
called the client, the one executing the procedure is the server. (In
more advanced applications, a single program may assume both roles
during the course of its execution.) Unsurprisingly, RPC is the
foundation of client/server computing [<a href="#fn1">1</a>]. While
RPC started out as a way to provide a transparent programming
experience for traditional, procedural models, it was quickly followed
by technologies that aimed to do the same for object-oriented
programming. Examples include DCOM, CORBA, and RMI (for which you
basically have to replace <em>procedure</em> with <em>method</em> in the next few
paragraphs).</p>

<p>All of these technologies basically work the same way:</p>

<ol>
<li>The interface (the collection of procedures used by the client and
offered by the server) is specified, either in a language
specifically designed for this purpose or directly in the
programming language used to implement clients or servers (the
latter being the case for Java and C#).  2. A compiler generates
<em>stubs</em> and <em>skeletons</em>, i.e. code that represents the remote
procedure interface for both client and server.  3. At runtime, the
stub forwards requests to the remote location; the skeleton accepts
network requests and dispatches them to the implementation. As
there is a lot of functionality in place here that is independent
from the remote interface, this is done with the help of a library
that is linked into the client and server applications,
respectively.</li>
</ol>

<h3>RPC-style Web Services</h3>

<p>Treating all of the RPC and OO-RPC technologies as equivalent
naturally does not do them justice; they differ in aspects such as
programming language and operating system independence, the handling
of (stateful) conversations, object identity (or lack thereof), data
marshaling protocols, interface description language, industry
support, performance, transport (in)dependence and many more. Still, I
maintain that the philosophy is very similar.</p>

<p>So let&#8217;s (finally!) talk about RPC-style Web services [<a href="#fn2">2</a>]. It seems very natural to view Web services as
simply the next in a line of ever-improving RPC technologies. In fact,
Web services explicitly started out with this goal &#8212; one of the most
obvious signs of this is the name of SOAP&#8217;s ancestor, XML-RPC [<a href="#fn3">3</a>]. Basically, the same development pattern is used,
with two distinctions:</p>

<ul>
<li>The &#8220;IDL&#8221; used is the XML-based WSDL,</li>
<li>the parameters of the remote call are marshalled as XML (and put
into a SOAP envelope).</li>
</ul>

<p>Usually, the protocol used for transporting the marshalled request
from client to server (and the response back from server to client) is
HTTP; this is less important though, since Web services are supposed
to work with lots of different transports [<a href="#fn4">4</a>].</p>

<p>There&#8217;s some advantages this approach has over traditional RPC, CORBA,
etc.; there&#8217;s an (at least) equal amount of disadvantages. I&#8217;m not
alone in believing that the RPC-style Web services largely fail to
exploit the possibilities the underlying technologies offer. But let&#8217;s
take a look at the advantages first.</p>

<h3>Advantage 1: Industry Support</h3>

<p>No other RPC technology ever had the same amount of industry
support. For years, there was a war between Microsoft&#8217;s DCOM and the
rest of the world&#8217;s CORBA, leading to fragile bridging solutions and
frustrated users. Web services and the associated standards &#8212;
especially XML, SOAP, and WSDL &#8212; are almost universally
supported. Almost every commercial software vendor has introduced or
plans to introduce support for these technologies into their products
and tools.</p>

<h3>Advantage 2: Interop</h3>

<p>While it was entirely possible to get a Microsoft and a Unix
application to talk to each other using DCE-RPC or CORBA, today is the
first time it&#8217;s possible to do so using the respective vendors own
technology &#8212; with at least some level of interoperability. As long as
quite a few rules regarding what data types and programming constructs
may be used are followed, it&#8217;s possible to get a .NET consumer talk to
a WebSphere or WebLogic provider or vice versa. </p>

<h3>Advantage 3: Ease of use</h3>

<p>RPC is a paradigm most developers are familiar with, and if they
aren&#8217;t, they can pretty easily &#8220;get it&#8221; in a few hours. With decent
IDE support, there&#8217;s no need for the developer to bother with any of
the lower-level details such as the network protocols being used [<a href="#fn5">5</a>].</p>

<h3>Advantage 4: Composability of add-ons for non-functional aspects</h3>

<p>The coolest feature of SOAP &#8212; and thus one that is available for
RPC-style Web services as well &#8212; is its support for extensibility by
means of SOAP headers. In contrast to e.g. IIOP, there&#8217;s a clearly
specified model for passing any sort of contextual information with
your method invocations, and XML together with namespaces provides the
necessary technology to compose one or more of <a href="/soa/ws-standards/">the multitude of WS-* specifications </a>
that exist for many different purposes. Even RPC-centric programming
models such as <a href="http://jcp.org/en/jsr/detail?id=101">JAX-RPC</a> [6] provide a
way to get access to SOAP headers during message processing, and of
course toolkits implement many existing specs such as <a href="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0.pdf">WSS</a>
by default.</p>

<h3>The Problem</h3>

<p>So why do I think RPC-style Web services should not be the way to go?
Doesn&#8217;t this all sound perfectly reasonable, with a long history of
succcesful predecessors to show that this approach works? </p>

<p>In fact I think that in those cases where CORBA or DCOM might have
worked just as well as RPC-style Web services, they should probably
have been used in the first place. CORBA is a very good and proven
technology for use in scenarios where client and server are tighly
coupled to each other &#8212; usually scenarios where you control both
sides. RPC-style Web services are just as tightly-coupled as DCOM or
CORBA; they don&#8217;t make use of XML&#8217;s extensibility, or HTTP&#8217;s generic
interface (more on that later). Let&#8217;s take a closer look.</p>

<h3>Self-descriptiveness</h3>

<p>One of the nice things about XML is that it carries not only data, but
also descriptive information about that data. Consider the following
piece of information:</p>

<pre><code>4711    Joe Doe           3    36.5 2005-05-02
</code></pre>

<p>What can you do with this? You might take a guess, e.g. that there&#8217;s a
name somewhere and a date, but this is not going to help you get very
far. Clearly, though, you need some information about the structure up
front to process this. So take a look at this:</p>

<pre><code>4711    Joe Doe           3    36.5    2005-05-02
-order#-| -- name -------|amnt|-price-|deliverydate
</code></pre>

<p>So this might actually be a purchase order, containing an order
number, a name of the buyer, an amount, a price, and a delivery date.</p>

<p>Who knows about this? In an RPC scenario, this information is part of
the interface description. From this, the stubs and skeletons for
client and server are generated. This way, both know what the data
looks like, i.e. they expect an order number, than a name, amount,
etc.</p>

<p>So what, you ask? The problem is two-fold:</p>

<ol>
<li><p>It&#8217;s redundant. Here&#8217;s what a SOAP message encapsulating the
information from above might look like:</p>

<pre>
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
&lt;e:Envelope xmlns:d="http://www.w3.org/2001/XMLSchema"
xmlns:e="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
&lt;e:Body>
&lt;sns:order i:type="sns:Order" xmlns:n0="http://example.org/somenamespace">
&lt;sns:amount i:type="d:int">3&lt;/sns:amount>
&lt;sns:deliveryDate i:type="d:dateTime">2005-05-01T23:59:50.971+02:00&lt;/sns:deliveryDate>
&lt;sns:name i:type="d:string">Joe Doe&lt;/sns:name>
&lt;sns:ordernumber i:type="d:string">4711&lt;/sns:ordernumber>
&lt;sns:price i:type="d:double">36.5&lt;/sns:price>
&lt;/sns:order>
&lt;/e:Body>
&lt;/e:Envelope>
</pre>

<p>What&#8217;s the point of transmitting all of the meta information, such
as the names of the attributes here when client and server expect
it anyway? Because changes are easier to handle? Wrong; see below.</p>
</li>
<li><p>It&#8217;s as tighly coupled as older RPC technologies. A change to the
procedure signature will break a communication partner if it&#8217;s not
updated to the newest interface immediately &#8212; which usually
requires re-compilation and/or re-linking, the reason being that
both sides depend on the complete interface because that&#8217;s what the
proxies have been generated for.</p></li>
</ol>

<p>Basically, there&#8217;s simply no point in using XML this way: you might
just as well stick with CORBA or DCOM and save some bandwidth.</p>

<h3>Conclusion</h3>

<p>In the end, RPC-style Web services combine all of the disadvantages of
traditional RPC-style solutions, such as tight coupling between client
and server, with the performance and bandwidth disadvantages of XML
and HTTP [<a href="#fn7">7</a>] without exploiting any of its benefits. Your use case may
mean the the simple interoperability benefits alone justify their
usage, but there&#8217;s no ground-breaking difference to earlier
technologies. There&#8217;s much more you can do once you accept that
there&#8217;s a difference to Distributed Objects - and I&#8217;ll explore that
some more in the next part of this mini-series.</p>

<h3>Footnotes</h3>

<p>Thanks to <a href="/blog/mt/">Marcel</a> for valuable feedback on an
earlier draft. </p>

<p><a name="fn1">[1]</a> The first popular RPC solution was introduced by
Sun (Sun RPC, later called ONC RPC) together with NFS, the Network
File System. It featured all the important parts of more modern
incarnations: An interface description with an associated
stub/skeleton generator, marshaling, even a (albeit very simple)
registry (<code>portmap(8)</code>). I just checked and was pleasantly surprised
that my 2005 Mac OS X Tiger installation still includes <code>rpcgen(1)</code>,
which even supports transport independence (I don&#8217;t think the original
Sun RPC did). The other important RPC standard is DCE RPC, which is
also used as the foundation of Microsoft&#8217;s DCOM.</p>

<p><a name="fn2">[2]</a> Note that this has got (almost) nothing to do with the
document/literal vs. rpc/encoded discussion of SOAP styles and
encodings. While it&#8217;s hard to do anything but RPC with rpc/encoded,
it&#8217;s entirely possible to do RPC with doc/lit, and simply switching
from rpc/enc to doc/lit buys you exactly nothing in this respect.</p>

<p><a name="fn3">[3]</a> In my opinion, XML-RPC will always have an honored place as the
worst protocol ever designed.</p>

<p><a name="fn4">[4]</a> This is (hopefully) the last time I&#8217;ll use &#8220;transport&#8221; to describe
what HTTP is; it&#8217;s not a transport, but a transfer protocol. More on
that later.</p>

<p><a name="fn5">[5]</a> I don&#8217;t believe this at all (see below), but it&#8217;s an advantage that is pointed
out by proponents of this approach. </p>

<p><a name="fn6">[6]</a> Despite the name, JAX-RPC 2 (which is currently
under development in the JCP as <a href="http://www.jcp.org/en/jsr/detail?id=224">JSR 224</a>) does in
fact provide means to build message-style Web services as well. Any
JAX-RPC 2 compliant implementation will have to provide the RPC-style
programming model as well, though.</p>

<p><a name="fn7">[7]</a> In fact I don&#8217;t really believe that there&#8217;s a
notable performance hit when using HTTP and XML in real-world
applications, provided they are used the way they are supposed to
(document/resource representation exchange). Most often
gzip-compressed XML rendering of some object will take less space than
a dumb binary representation such as the default Java serialization one.</p>
<section class="comments">

<div class="comment" id="comment-538">
On <a href="#comment-538" title="Permalink to this comment">July 12, 2005 11:13 AM</a>, Enric Jaen
said:
<p>I don&#8217;t agree.. From my point of view, there is one mayor reason why RPC web services are necessary: Microsoft is involved.
CORBA is an excellent OO middleware, but without the support of Microft, and the counterpart for DCOM. So  the only technology that really interoperates between the Microsoft world and the rest of the world is RPC Web Services.</p>

<p><div class="comment" id="comment-539">
On <a href="#comment-539" title="Permalink to this comment">July 12, 2005 11:14 AM</a>, Enric Jaen
said:
<p>I don&#8217;t agree.. From my point of view, there is one major reason why RPC web services are necessary: Microsoft is involved.
CORBA is an excellent OO middleware, but without the support of Microft, and the counterpart for DCOM. So  the only technology that really interoperates between the Microsoft world and the rest of the world is RPC Web Services.</p></p>

<p><div class="comment" id="comment-540">
On <a href="#comment-540" title="Permalink to this comment">August  3, 2005  2:21 AM</a>, <a href="http://arnosoftwaredev.blogspot.com/" title="http://arnosoftwaredev.blogspot.com/" rel="nofollow">Arno</a>
said:
<p>I think many Webservice evangelist have failed in explaining when to use Webservices (and when not), and how to achieve loose coupling by SOA and document-oriented approaches.  </p></p>

<p>I know of several projects where - thanks to all that hype around it - Webservices are completely misused, and serve as nothing else than just another intranet / single platform RPC protocol (where IIOP or DCOM would be much better suited). </p>

<p>Webservices are for integration, not for inter-tier distribution!</p>

<p><div class="comment" id="comment-541">
On <a href="#comment-541" title="Permalink to this comment">August  3, 2005  7:10 AM</a>, <a href="/en/staff/st/">Stefan Tilkov</a>
said:
<p>Arno, I agree - I have seen the occasional use of Web services as an intra-app middleware that made sense, but this is clearly not the scenario the WS-* stack has been built for.</p></p>

<p><div class="comment" id="comment-542">
On <a href="#comment-542" title="Permalink to this comment">August 26, 2005  6:49 PM</a>, Jacek
said:
<p>Hi Stefan, I accept the oversimplifications and the annoyingly obvious things (cited 8-) ), but I think there&#8217;s one minor error: skeletons are not generated dispatchers (as you describe them), they are instead (at least in my limited experience) actual skeleton code that has to be filled in by the programmer of the service (object, procedure) in order to be sure the interface matches the dispatcher&#8217;s expectations based on its mapping rules and the IDL.</p></p>

<p>To react to comments, I think Enric has in his mind exactly the use case where the benefits of interop outweigh the benefits of using proven and performing older technologies.</p>

<p><div class="comment" id="comment-543">
On <a href="#comment-543" title="Permalink to this comment">November 23, 2006 12:05 PM</a>, Jakob
said:
<p>&#8220;A change to the procedure signature will break a communication partner if it’s not updated to the newest interface immediately &#8220;</p></p>

<p>Thats not quite true. Most WebService implementations allow the server to add or remove parameters, without the client breaking, as long as the client does not need the parameter. Thats different in Corba for example</p>

<p>Best regards
Jakob</p>

<p><div class="comment" id="comment-544">
On <a href="#comment-544" title="Permalink to this comment">November 23, 2006 12:21 PM</a>, <a href="/en/staff/st/">Stefan Tilkov</a>
said:
<p>What you describe is how it should be; sadly it does not reflect the way toolkits actually work. You can find out more here:</p></p>

<p><a href="/blog/dm/2006/03/changing\_interf\_1.html" rel="nofollow" /><a href="/blog/dm/2006/03/changing_interf_1.html" rel="nofollow">http://www.innoq.com/blog/dm/2006/03/changing_interf_1.html</a></p>

<p></section></p>

	</section>
      </article>
    </main>

  </body>
</html>


