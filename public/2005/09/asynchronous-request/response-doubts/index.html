<!DOCTYPE html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="Stefan Tilkov">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="canonical" href="https://www.innoq.comhttps://www.innoq.com/blog/st/2005/09/asynchronous-request/response-doubts/">
  <link href="/blog/st/favicon.png" rel="icon">
  <link href="/blog/st/atom.xml" rel="alternate" title="Stefan Tilkov's Blog" type="application/atom+xml">


  <link rel="stylesheet" href="https://bootstrap.assets.innoq.com/css/0.0.9/innoq-bootstrap-theme.css" />
  <link rel="stylesheet" href="/blog/st/stylesheets/blog.css" />

  <title>Asynchronous Request/Response Doubts [Stefan Tilkov’s Blog]</title>
  
</head>


  <body>

    <nav class="navbar navbar-expand-lg navbar-light">
  <a class="navbar-brand m-2 p-2" href="https://www.innoq.com/"><img alt="INNOQ logo" height="40" src="https://innoq.style/assets/innoq-logo--whitered.svg" /></a>
  <a class="navbar-brand text-light" href="/blog/st/">Stefan Tilkov’s Blog Archive</a>
</nav>





    <main class="container">
      <p class="mt-5"><em>
	This is a single archived entry from Stefan Tilkov’s blog. For more up-to-date content,
	check out my <a href="https://www.innoq.com/en/staff/stefan-tilkov/">author page at INNOQ</a>,
	which has more information about me and also contains a list of published talks, podcasts, and articles.
	Or you can check out the <a href="/blog/st/">full archive</a>.

      </em></p>
      <article>
	<header>
          <h1>Asynchronous Request/Response Doubts</h1>
	  <p><small><a href="https://www.innoq.com/en/staff/stefan-tilkov/">Stefan Tilkov</a>, <time datetime="2017-06-26">Sep 6, 2005</time></small><p>
	</header>
	<section>
	  <p>Everybody and their mother agrees that doing web services RPC-style is a Bad Thing&trade;, but not many people would extend that to request/response, which is a useful and common pattern in any sort of remote communication scenario. It&#8217;s not as easy as one might imagine, though, to find out how the SOAP, WSDL and WS-A specs and the rest of WS-* stack can be used to support this pattern when combined with asynchronous messaging.</p>

<p>One approach is to view request/response as a logical pattern, independent from the transport or transfer protocol being used.
The WSDL 1.1 note at W3C &#8212; a note because WSDL 1.1 is not a W3C recommendation &#8212; has <a href="http://www.w3.org/TR/wsdl#_request-response">this paragraph</a>, which supports this:</p>

<blockquote>
<p>Note that a request-response operation is an abstract notion; a particular binding must be consulted to determine how the messages are actually sent: within a single communication (such as a HTTP request/response), or as two independent communications (such as two HTTP requests).</p>
</blockquote>

<p>I haven&#8217;t been able to find an example of a binding that uses this; interestingly, though, the recently published IBM RAMP profile clarifies and extends the WS-I guidelines as follows, clearly supporting the WSDL 1.1 view:</p>

<blockquote>
<p>In the context of the WS-I Basic Profile, the only reason the response message to an HTTP request would be
empty is when the request message is a one-way message. However, the WS-Addressing specification
introduces a <code>wsa:ReplyTo</code> SOAP header block that changes the nature of a request/response WSDL operation
as it relates to the HTTP binding. If a request message includes a <code>wsa:ReplyTo</code> header that does not use the
WS-Addressing Anonymous URI, then the response message is expected to be sent to the wsa:ReplyTo
endpoint reference (EPR) rather than in the HTTP response message. Since the response message will not be
sent in the HTTP response message, the HTTP response code on the original connection would be &#8220;202
Accepted&#8221;. While this doesn&#8217;t violate any WS-I Basic Profile requirements it is a change in behavior.</p>
</blockquote>

<p>When viewed this way, a request/response interaction is a logical pattern, while its mapping to either a single request/response transport interaction or two one-way message transfers is a non-functional aspect. If it is, though, I still haven&#8217;t been able to find a formalized way to express this (i.e. indicate to the runtime that it is supposed to treat the request/response interaction this way).</p>

<p>There&#8217;s also a second approach: View a logical request/response interaction as something that is conceptually one level above what is described by WSDL. This <a href="http://www.w3.org/TR/2005/WD-wsdl20-adjuncts-20050803/#http-operation-decl-dest">seems to be supported by WSDL 2.0</a>, not yet, but soon supposed to become a W3C standard (recommendation): </p>

<blockquote>
<p>This binding extension specification provides a binding to HTTP of Interface Operation components whose {message exchange pattern} property has the value &#8220;http://www.w3.org/2005/08/wsdl/in-only&#8221;, &#8220;http://www.w3.org/2005/08/wsdl/robust-in-only&#8221; or &#8220;http://www.w3.org/2005/08/wsdl/in-out&#8221;. This HTTP binding extension MAY be used with other message exchange patterns such as outbound message exchange patterns, provided that additional semantics are defined, such as with an extension or with a Feature.<br /> Each of the supported message exchange patterns involves one to two messages or faults being exchanged. The first is transmitted using an HTTP request, and the second is transmitted using the corresponding HTTP response. In cases where only one message is being sent, the message body of the HTTP response MUST be empty.</p>
</blockquote>

<p>Based on this, the only correct way to map a WSDL 2.0 request/response to HTTP (as one example) is to use the synchronous transport/transfer mechanism. To support a logical request/response interaction, one can use two WSDL one-ways (where the rule of the empty response is obviously violated by the RAMP profile (which is not a problem since it relies on WSDL 1.1)). In this case, though, some other mechanism is needed to indicate to the runtime infrastructure that two one-way messages should be correlated. </p>

<p>The motivation for this discussion is that the technology stack we&#8217;re currently using in one of my projects &#8212; a JBI container &#8212; quite directly maps WSDL 2.0 MEPs to runtime API constructs. If something is a WSDL 1.1 request-response (WSDL 2.0 in-out), the corresponding <code>MessageExchange</code> created at runtime will be an <code>InOut</code> object. This object will be used to send the request. When the JBI container receives an incoming response &#8212; even asynchronously, e.g. when using JMS or WS-A-based async HTTP messaging &#8212; it expects the InOut exchange which was used to send the request to be still alive. If it isn&#8217;t, it&#8217;ll view this as an error. But when something such as RAMP is used, the response might arrive not only minutes, but even days after the request has been sent.</p>

<p>We&#8217;re still trying to come up with a solution that seems natural enough for the poor person tasked with designing the WSDL, does not require us to implement lots of message-correlating infrastructure on top of JBI, and doesn&#8217;t seem like we&#8217;re abusing the technology &#8230; maybe what we need is a new WSDL 2.0 MEP (<code>robust-in-robust-out</code> ?)</p>

<section class="comments">

<div class="comment" id="comment-612">
On <a href="#comment-612" title="Permalink to this comment">September  7, 2005  5:44 AM</a>, <a href="http://jim.webber.name" title="http://jim.webber.name" rel="nofollow">Jim Webber</a>
said:
<p>You should use SSDL. These ridiculous WSDL 2.0 artefacts don&#8217;t exist when you consider the problem in terms of abitrary message exchange rather than some pre-canned silliness.</p>

<p>Jim</p>


<div class="comment" id="comment-613">
On <a href="#comment-613" title="Permalink to this comment">September  7, 2005  6:41 AM</a>, <a href="/en/staff/st/">Stefan Tilkov</a>
said:
<p>Granted, request/response is just one of many useful patterns - such as request/response/response or subscribe/notify. It&#8217;s the most common, though, and one everybody expects to be supported.</p>

<p>I&#8217;m inclined to believe SSDL is superior in this regard; it&#8217;s not an option though for many reasons, most of them political.</p>


<div class="comment" id="comment-614">
On <a href="#comment-614" title="Permalink to this comment">September  7, 2005  1:17 PM</a>, <a href="http://jacek.cz/blog/" title="http://jacek.cz/blog/" rel="nofollow">Jacek</a>
said:
<p>Hi Stefan, there are a few points in reply:</p>

<p>1) extensions and bindings in WSDL 2 are basically free to map in-out to asynchronous exchange. I believe it is expected that WS-Addressing WSDL binding will provide such an extension and change the current WSDL HTTP binding to support asynchrony through two HTTP requests for the messages. It might make sense to allow robust-request-response MEP in this case.</p>

<p>2) the robust-request-response MEP allows you to send fault as a reaction to the response, and it is in effect robust-request-robust-response. The robustness here is about being able to fault on normal messages, not about any kinds of synchrony.</p>

<p>3) As for long-running vs. short-running asynchrony, that is an orthogonal decision here. In WASP we had two kinds of async that could be combined (this is info from when I was working on it two years ago, I&#8217;m not sure if it changed):</p>

<p>a) server-side/transport asynchrony - receiving the message over one transport channel and sending response back over a different channel. This is useful both for timeout issues (you can&#8217;t keep one channel open long enough) and networking issues (you plain don&#8217;t have a back channel, like in email transport).</p>

<p>b) client-side asynchrony - instead of modeling the request/response operation as simple Java call, it would be modeled with a callback/polling interface. This is useful for when the client-side processing model makes more sense asynchronously. This can be combined freely with synchronous or asynchronous transport:</p>

<ul>
<li><p>a short-term asynchronous transport with synchronous client call - for example a quick email exchange in absence of HTTP.</p></li>
<li><p>a synchronous transport with async client call - the client doesn&#8217;t care that the result is there in seconds, it can still do something useful in between.</p></li>
<li><p>a long-term async transport handled by async client call - normal async operation</p></li>
<li><p>a synchronous transport and synchronous client call - the well-known default behavior. 8-)</p></li>
</ul>

<p>We might invent an extension marker for WSDL that would say &#8220;this operation will run long&#8221;, indicating that the client might choose an async calling model for this request/response op, and that the server might choose an async binding because otherwise it would run into timeouts. I don&#8217;t know of anybody working on such an extension.</p>

<p>I hope this makes sense, the input box is awfully small. 8-)</p>

<p>Jacek</p>


<div class="comment" id="comment-615">
On <a href="#comment-615" title="Permalink to this comment">September  8, 2005  9:58 AM</a>, <a href="http://enricjaen.blogspot.com/" title="http://enricjaen.blogspot.com/" rel="nofollow">enric jaen</a>
said:
<p>You said:
&#8220;Everybody and their mother agrees that doing web services RPC-style is a Bad Thing™&#8221;</p>

<p>Please, could you explain a bit more why do you say RPC is a bad thing? Do you refer rpc/enc? If the problem is the encoding, you can use the wrapped style [1]</p>

<p>Regarding the asynchronous pattern, I think that the way to correlate two one-way messages is using the wsa:messageId and wsa:relatesTo. (This is something SSDL leaves unclear)</p>

<p>I have a question, do you consider that DOC-style is a resemble of the MOM-paradigm? According to [2] I think so..</p>

<p>[1]
<a href="http://www-128.ibm.com/developerworks/websphere/library/techarticles/0505_flurry/0505_flurry.html" rel="nofollow" /><a href="http://www-128.ibm.com/developerworks/websphere/library/techarticles/0505" rel="nofollow">http://www-128.ibm.com/developerworks/websphere/library/techarticles/0505</a><em>flurry/0505</em>flurry.html</p>

<p>[2] <a href="http://java.sun.com/developer/technicalArticles/xml/jaxrpcpatterns/#1" rel="nofollow" /><a href="http://java.sun.com/developer/technicalArticles/xml/jaxrpcpatterns/#1" rel="nofollow">http://java.sun.com/developer/technicalArticles/xml/jaxrpcpatterns/#1</a></p>

<p>-Enric</p>


<div class="comment" id="comment-616">
On <a href="#comment-616" title="Permalink to this comment">September  8, 2005 10:51 AM</a>, <a href="/en/staff/st/">Stefan Tilkov</a>
said:
<p>Hi Enric, </p>

<p>As to your first question, see this discussion:
<a href="/blog/st/2005/05/18/rpcstyle_web_services.html" rel="nofollow" /><a href="/blog/st/2005/05/18/rpcstyle" rel="nofollow">/blog/st/2005/05/18/rpcstyle</a><em>web</em>services.html</p>

<p>You are of course right with regards to wsa:ReplyTo/wsa:MessageID/wsa:RelatesTo, but my point is that there is no accepted way to describe this in WSDL.</p>


<div class="comment" id="comment-617">
On <a href="#comment-617" title="Permalink to this comment">September  8, 2005 11:28 AM</a>, <a href="/en/staff/st/">Stefan Tilkov</a>
said:
<p>Jacek, thanks for the thorough feedback. I&#8217;ve made the comment box wider, hope it suits you now :-)</p>

<p>I think we can agree that API-level asynchronicity (which is probably better termed blocking/non-blocking) is completely orthogonal to transport semantics. If bindings can map an in/out to two one-way transport messages, this means that from the WSDL interface perspective, the correct way to describe an in/out (request/response) exchange is to use the in/out MEP instead of explicitly modeling it as one in and one out (or one robust-in&#8217; and one &#8216;robust-out&#8217;) MEPs.</p>

<p>If this is the case, it would be wrong (or at least not in line with the goal of the spec) for an API and programming toolkit to map a WSDL in/out to some message exchange object that will only live as long as the calling process does, without offering any way for a consumer to receive a response message that arrives asynchronously after a restart. So it&#8217;s an API problem, not a WSDL or binding problem.</p>

<p>It seems, though, that there&#8217;s a difference between the view taken by WSDL 1.1 and WSDL 2 &#8212; where in WSDL 2, in/out is a MEP that can be used for long-running + asynchronous, short-running + asynchronous as well as short-running + synchronous invocations, a WSDL 1.1 request/response can only map to a synchronous transport invocation. Which contradicts the RAMP profile &#8230;</p>


<div class="comment" id="comment-618">
On <a href="#comment-618" title="Permalink to this comment">September  8, 2005  3:22 PM</a>, <a href="http://jacek.cz/blog/" title="http://jacek.cz/blog/" rel="nofollow">Jacek</a>
said:
<p>Wow, now it&#8217;s big enough. Please do the same change on the preview page. 8-)</p>

<p>As for the difference between WSDL 1.1 view and WSDL 2 view, I thought I read your original article above as saying exactly the opposite from the last comment. 8-) </p>

<p>In the article, you quote WSDL 1.1 explicitly describing the abstractness of the request/response MEP, supported by text from RAMP. Then you quote WSDL 2 and interpret it to say that in-out is only synchronous, which can be changed by extensions, as I commented. Now in your latest comment you say it the other way. What gives? 8-)</p>

<p>As I see it, both WSDL 1.1 and WSDL 2 allow in-out (or request/response) to be mapped to multiple channels, and neither of them actually does so in the standard bindings. We can hope WS-Addressing WG does a good job here and provides a useful extension for WSDL 2; and maybe they will even go as far as porting it to WSDL 1.1.</p>


<div class="comment" id="comment-619">
On <a href="#comment-619" title="Permalink to this comment">September  8, 2005  3:46 PM</a>, <a href="/en/staff/st/">Stefan Tilkov</a>
said:
<p>Yes, you are right - I managed to confuse myself :-)</p>


</section>

	</section>
      </article>
    </main>

  </body>
</html>


