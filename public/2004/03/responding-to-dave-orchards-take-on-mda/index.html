<!DOCTYPE html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="Stefan Tilkov">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="canonical" href="https://www.innoq.comhttps://www.innoq.com/blog/st/2004/03/responding-to-dave-orchards-take-on-mda/">
  <link href="/blog/st/favicon.png" rel="icon">
  <link href="/blog/st/atom.xml" rel="alternate" title="Stefan Tilkov's Blog" type="application/atom+xml">


  <link rel="stylesheet" href="https://bootstrap.assets.innoq.com/css/0.0.9/innoq-bootstrap-theme.css" />
  <link rel="stylesheet" href="/blog/st/stylesheets/blog.css" />

  <title>Responding to Dave Orchard&#39;s Take on MDA [Stefan Tilkov’s Blog]</title>
  
</head>


  <body>

    <nav class="navbar navbar-expand-lg navbar-light">
  <a class="navbar-brand m-2 p-2" href="https://www.innoq.com/"><img alt="INNOQ logo" height="40" src="https://innoq.style/assets/innoq-logo--whitered.svg" /></a>
  <a class="navbar-brand text-light" href="/blog/st/">Stefan Tilkov’s Blog Archive</a>
</nav>





    <main class="container">
      <p class="mt-5"><em>
	This is a single archived entry from Stefan Tilkov’s blog. For more up-to-date content,
	check out my <a href="https://www.innoq.com/en/staff/stefan-tilkov/">author page at INNOQ</a>,
	which has more information about me and also contains a list of published talks, podcasts, and articles.
	Or you can check out the <a href="/blog/st/">full archive</a>.

      </em></p>
      <article>
	<header>
          <h1>Responding to Dave Orchard&#39;s Take on MDA</h1>
	  <p><small><a href="https://www.innoq.com/en/staff/stefan-tilkov/">Stefan Tilkov</a>, <time datetime="2017-06-26">Mar 18, 2004</time></small><p>
	</header>
	<section>
	  <p><a href="http://www.pacificspirit.com/blog/2004/03/03/model_driven_architecture_thoughts_its_hard">Dave Orchard had some thoughts about MDA</a>, and I commented on his blog entry very briefly. I&#8217;ll try to address each of his claims in more detail below. I have elaborated many of the points <a href="/blog/st/archives/000177.html">in an older posting</a>; it might be a good idea to read it if you&#8217;re looking for some initial discussion.</p>

<p>Dave says:</p>

<blockquote>The first lesson to learn for MDA is that &#8220;abstractions&#8221;, like a logical model, typically worsen performance and there is a need for selectively optimizing performance.</blockquote>

<p>First of all, I think a logical model is something that you just can&#8217;t avoid having &mdash; if you design any sort of application, you&#8217;ll have a conceptual model of your entities, their relationship, your processes, and so on, regardless of whether you actually draw this as a UML model in some fancy CASE tool, on a napkin, or just keep it all in your mind. You will think of he Customer having n Contracts, and each Contract referring to n Articles, or something like that; it&#8217;s highly  unlikely that you will think of your application&#8217;s concepts in terms of the underlying technology.</p>

<p>The point Dave is trying to make is, if I guess correctly, that having a uniform way for mapping this logical model to a specific implementation strategy worsens performance. That&#8217;s true, and it is a common trade-off: Uniformity will make your system easier to understand because things look more or less the same; it will not offer the same performance as the manually tuned solution that can take all of the specifics into account.</p>

<p>While I agree in principle, I believe that in every (complex) application, you will have some guidelines that describe the default &#8220;mapping&#8221;. In most J2EE applications, for example, you will decide on one general strategy - such as &#8220;We will use EJB CMP&#8221; or &#8220;we&#8217;ll use Hibernate&#8221; - and stick with it, except for the places where it&#8217;s justified to deviate from your own standards.</p>

<p>As you will always have a standard way of doing things, an MDA approach will automate this, saving you time; it will localize the concept in a single place, so that it&#8217;s easy to understand; it will increase quality, since you&#8217;ll be doing it the same way automatically; and it will allow you to evolve your strategy should you find out that it can be improved.</p>

<p>Dave continues:</p>

<blockquote>We had a bigger problem though: The developers hated it. Somebody would create the logical model, they&#8217;d push the &#8220;generate&#8221; code button, and then run the software. But guess what, they always got the model wrong. Maybe they forgot about the zip code in the address, or the middle name in the name structure. So the model needed to be updated. </blockquote>

<p>So far, I see no problem &mdash; you of course don&#8217;t get everything right the first time, so you&#8217;ll have to update and change your model. I fail to see anything particularly tied to an MDA approach so far. The actual problem seems to be described in the next two sentences:</p>

<blockquote>To make a simple change in the model and then generate took way too long. It could take up to half an hour before the system could be retested. The devs simply would make the change they needed in the place they needed it. For example, the SQL already had the zip code so they only needed to add the zip code in the Java and in the SQL select.</blockquote>

<p>If it takes half an hour to do this, something is wrong with your tool set. There are generators that can generate hundreds of files in under a minute; depending on the CASE tool, the XMI export itself may sometimes take longer than the actual code generation step. </p>

<p>Even more importantly, in my experience the example given (&#8220;they only needed to add the zip code in the Java and in the SQL select&#8221;) is an argument that clearly shows where the strengths, not the weaknesses of MDA lie: In a real-world architecture, you&#8217;ll have to change the zip code in the SQL DDL, in the query string (as well as in the update and create statements); you&#8217;ll have to add it in the place where you extract the data; you&#8217;ll have to add it to some Java object, create getters and setters; extend some interface (e.g. in one of your EJBs); might have to add it to some FormBean, modify the code that copies it from some back-end object to the front-end object, etc. etc.</p>

<p>Saving time by doing this manually? I don&#8217;t think so.</p>

<p>Next quote:</p>

<blockquote>I assert that MDA systems almost invariably suffer from the &#8220;design documents collect dust on bookshelves&#8221; problem, despite best attempts of the tools and organization to stop the natural entropy</blockquote>

<p>I assert that anytime you use modeling, UML or not, and you <em>don&#8217;t</em> use an MDA approach, you will suffer from this problem (since the model just is part of the initial design documentation). With MDA, you make your model part of the development artifacts; it can&#8217;t get out of sync (that would be like part of your source code getting out of sync). Of course you have to enforce this, but this is no different than disallowing people from modifying the byte code emitted by javac. </p>

<blockquote>The technology simply introduces an artificial layer of abstraction that is too difficult to modify and build high performance systems.</blockquote>

<p>By the same logic, I could say that EJB CMP introduces a layer that makes it impossible to build high performance systems. Or Java. Or maybe even an RDBMS. After all, not being tied to the relational abstraction will allow me to build a faster system - right?</p>

<p>Stripping down the rest of Dave&#8217;s posting, I believe the key statements are</p>

<blockquote>A final problem with MDA systems is that they don&#8217;t really solve the hard problem. [&#8230;] A final problem with MDA systems is that they don&#8217;t really solve the hard problem. </blockquote>

<p>I totally agree; anybody who claims that MDA solves all problems, and turns it into a silver bullet, is clearly wrong. I believe that software development is hard; but it&#8217;s hard enough to deal with even <em>with</em> an MDA approach. <em>Without</em>, it becomes unnecessarily harder - I see no reason to do this.</p>

<p>Dave&#8217;s summary is:</p>

<blockquote>In conclusion, I believe that MDA systems solve a small portion of systems development and will typically suffer from the &#8220;stale design&#8221; and performance problems. I think the path forward for software development is perhaps to use MDA as a prototyping exercise, but the real productivity gains will come from ever increasing productivity tools (like better GUIs, APIs and programming models) and increasing metadata.</blockquote>

<p>As I hope to have made clear, I strongly disagree with the first part of this statement. Using MDA for prototyping only clearly misses the real benefits &mdash; and in my view, MDA is <em>only</em> about increasing productivity, nothing else.</p>

<p>I&#8217;m not a fan of statistics, and I don&#8217;t particularly believe in specific case studies being generalized to an overall productivity gain. But I know from experience that especially in scenarios where you have a big code base, a strong set of architectural guidelines, and an application that is more data-centric then process-centric, the productivity gains are <em>significant</em>. Especially with EJB/CMP-based backends, the percentage of generated code (for this layer) can be up to 100%.</p>

	</section>
      </article>
    </main>

  </body>
</html>


