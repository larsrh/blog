<!DOCTYPE html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="Stefan Tilkov">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="canonical" href="https://www.innoq.comhttps://www.innoq.com/blog/st/2007/06/rest-axis2-and-hypermedia/">
  <link href="/blog/st/favicon.png" rel="icon">
  <link href="/blog/st/atom.xml" rel="alternate" title="Stefan Tilkov's Blog" type="application/atom+xml">


  <link rel="stylesheet" href="https://bootstrap.assets.innoq.com/css/0.0.9/innoq-bootstrap-theme.css" />
  <link rel="stylesheet" href="/blog/st/stylesheets/blog.css" />

  <title>REST, Axis2, and Hypermedia [Stefan Tilkov’s Blog]</title>
  
</head>


  <body>

    <nav class="navbar navbar-expand-lg navbar-light">
  <a class="navbar-brand m-2 p-2" href="https://www.innoq.com/"><img alt="INNOQ logo" height="40" src="https://innoq.style/assets/innoq-logo--whitered.svg" /></a>
  <a class="navbar-brand text-light" href="/blog/st/">Stefan Tilkov’s Blog Archive</a>
</nav>





    <main class="container">
      <p class="mt-5"><em>
	This is a single archived entry from Stefan Tilkov’s blog. For more up-to-date content,
	check out my <a href="https://www.innoq.com/en/staff/stefan-tilkov/">author page at INNOQ</a>,
	which has more information about me and also contains a list of published talks, podcasts, and articles.
	Or you can check out the <a href="/blog/st/">full archive</a>.

      </em></p>
      <article>
	<header>
          <h1>REST, Axis2, and Hypermedia</h1>
	  <p><small><a href="https://www.innoq.com/en/staff/stefan-tilkov/">Stefan Tilkov</a>, <time datetime="2017-06-26">Jun 19, 2007</time></small><p>
	</header>
	<section>
	  <p><a href="http://www.bloglines.com/blog/sanjiva?id=227">Sanjiva Weerawarana</a>:</p>

<blockquote>
<p>Its easy to just create a programming model for handling basic HTTP requests. That was done years ago- in the Java world servlets and more. However, that doesn&#8217;t sovle the problem of how to handle the payload and make links that capture the state of the application in the form of those links. The part of REST which appears hard to get right at first is that of understanding how to make correct URIs and use the HTTP verbs correctly, but the really hard part IMO is how to manage the payload and have it capture links that capture the state of the application. The information Web has it a bit easy here .. the &#8220;state&#8221; is mostly captured in the current document and links just (relatively) navigate out of it - doing that for non-information-oriented RESTful applications is an order of magnitude harder. In other words, coming up with a solid programming model for resources is non-trivial .. and that&#8217;s why we&#8217;re still talking and debating about it.<br /><br />IMO the real underlying problem is that as long as programmers expect to write a class and flip a switch to get a service or one or more RESTful resources then we have nothing really but RPC masquerading as something else. Both resource and service advocates would be well-off in trying to move the developer community to get past the &#8220;class is all I need&#8221; stage. If REST is successful in getting developers to get their hands dirty more power to it.</p>
</blockquote>

<p>+1. And that says a lot ;-)</p>

<section class="comments">



<div class="comment" id="comment-1372">
On <a href="#comment-1372" title="Permalink to this comment">June 19, 2007 10:59 PM</a>, <a href="http://joerg-schaefer.biz/" title="http://joerg-schaefer.biz/" rel="nofollow">Joerg</a>
said:
<p>&#8220;So what&#8217;s the advantage of modeling the system as a set of entities and relations? Well then it maps to HTTP and REST easily and trivially - each entity is a URI and the relations become links that become embedded in the representation of the resource when you GET it&#8230;OK now rewind to the world of Java or object oriented programming languages.&#8221;</p>

<p>Philosophical remark:
Maybe what we need is a programming model that takes one of the few mathematically sound models of CS, namely relational theory, seriously (the other mathematically sound foundation is lambda calculus of course leading to functional programming). So rather than continuing with OO we need a proper programming abstraction for programming with relational algebra (entities, relations, RFD&#8230;).</p>


</section>

	</section>
      </article>
    </main>

  </body>
</html>


